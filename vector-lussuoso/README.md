## MyVector
Лабораторная 3. Задача 3
Вам нужно реализовать методы шаблонного класса Vector. Необходимо создать собственную реализацию динамического массива, аналогичного std::vector, который будет работать с произвольными типами данных. Класс должен поддерживать базовые операции, опеределенные в файле ```library.hpp```

Описание всех методов представлено ниже:
1. Vector()Конструктор по умолчанию. Создаёт пустой вектор. Обычно инициализирует внутренние указатели (data_) и размеры (size_, capacity_).
2. explicit Vector(size_t count, const T& value = T())Конструктор, создающий вектор с заданной длиной (count), заполненный значениями value. Полезен для быстрого создания вектора с определённым количеством элементов.
3. Vector(std::initializer_list<T> init)Конструктор, принимающий список инициализации std::initializer_list. Позволяет создавать вектор сразу с набором значений, например: Vector<int> v = {1, 2, 3};.
4. Vector(const Vector& other)Копирующий конструктор. Создает новый объект-вектор, копируя данные из другого объекта.
5. Vector& operator=(const Vector& other)Оператор присваивания. Позволяет одному вектору присвоить значения другого вектора. Возвращается ссылка на сам объект, чтобы поддерживать цепочки операций вида a = b = c;.
6. ~Vector()Деструктор. Освобождает выделенную память, занятую элементами вектора.
7. T& operator[](size_t index)Оператор индексации для неконстантных объектов. Возвращает ссылку на элемент по индексу, позволяя изменять значение элемента.
const T& operator[](size_t index) constТо же самое, что и предыдущий оператор, но для константных объектов. Возвратит неизменяемый элемент.
8. T& at(size_t index)Метод для безопасного доступа к элементу по индексу. В отличие от оператора [], проверяет границы индекса и бросает исключение std::out_of_range, если индекс выходит за пределы допустимого диапазона.
const T& at(size_t index) constКонстантная версия метода at, аналогичная п.9, но возвращающая неизменяемое значение.
9.  size_t size() constВозвращает количество элементов в векторе.
10. size_t capacity() constВозвращает текущую ёмкость вектора — максимальное число элементов, которое можно хранить до перераспределения памяти.
11. bool empty() constПроверяет, пуст ли вектор. Если size() == 0, возвращает true.
Модификация размера:
12. void resize(size_t newSize, const T& value = T())Изменяет размер вектора. Если новый размер больше текущего, добавляются элементы с значением value. Если меньше — лишние элементы удаляются.
13. void reserve(size_t newCapacity)Резервирует место для хранения элементов, увеличивая ёмкость вектора. Это полезно для предотвращения частого перераспределения памяти при увеличении вектора.
14. void push_back(const T& value) Добавляет элемент в конец вектора. Если текущей ёмкости недостаточно, вызывается резервирование памяти.
15. void pop_back() Удаляет последний элемент вектора.
16. void clear()Очищает вектор, оставляя его пустым, но сохраняя прежнюю ёмкость.

## Запуск Сборки и тестов через терминал

```bash
cmake -B build # Генерируем файлы сборки
cmake --build build # Собираем
cd build # Заходим в дерикторию сборки
ctest --output-on-failure # Запуск тестов
```